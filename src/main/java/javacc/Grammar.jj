options {
	DEBUG_PARSER = true;
}


PARSER_BEGIN(Parser)
package javacc;
import interpreter.*;
import interpreter.ast.*;
import interpreter.ast.expression.*;
import interpreter.ast.expression.constant.*;
import interpreter.ast.globalscope.*;
import interpreter.ast.globalscope.struct.*;
import interpreter.ast.statement.iteration.*;
import interpreter.ast.statement.*;
public class Parser {
	public static void main(String args[]) throws ParseException {

		try {
			Parser parser = new Parser(System.in);
			parser.start();
		}

		catch (Exception e) {
		    System.out.println(e.getMessage());
			throw new Error("Parsing isleminde hata !");
		}
	}
}

PARSER_END(Parser)

/* WHITE SPACE */

SKIP : {
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}


TOKEN : {

	< IF : "if" >
|	< ELSE : "else" >
|	< FOR : "for" >
|	< WHILE : "while" >
|	< DO : "do" >
|	< SWITCH : "switch" >
|	< CASE : "case" >
|	< DEFAULT_ : "default" >
|	< BREAK : "break" >
|	< CONTINUE : "continue" >
|	< STRUCT : "struct" >
|	< RETURN : "return" >
|	< CONST : "const" >
|	< TRUE : "true" >
|	< FALSE : "false" >
|	< VOID : "void" >
|	< INT : "int" >
|	< BOOL : "bool" >
|	< DOUBLE : "double" >
|	< STRING : "string" >
|	< LPAREN : "(" >
|	< RPAREN : ")" >
|	< LBRACK : "[" >
|	< RBRACK : "]" >
|	< LBRACE : "{" >
|	< RBRACE : "}" >
|	< SEMI : ";" >
|	< COMMA : "," >
|	< COLON : ":" >
|	< DOT : "." >
|	< PLUS : "+" >
|	< MINUS : "-" >
|	< TIMES : "*" >
|	< DIVIDE : "/" >
|	< MODULO : "%" >
|	< POWER : "^" >
|	< ASSIGN : "=" >
|	< AND : "&&" >
|	< OR : "||" >
|	< NOT : "!" >
|	< EQUAL : "==" >
|	< NOTEQUAL : "!=" >
|	< LESSTHAN : "<" >
|	< GREATERTHAN : ">" >
|	< LESSEQUAL : "<=" >
|	< GREATEREQUAL : ">=" >
|   < PRINT: "print" >
|	< #LETTER : ["a"-"z", "A"-"Z", "_"] >
|	< #DIGIT : ["0"-"9"] >
|	< #SIGN : ["+", "-"] >
|	< #EXPONENT : ["e", "E"] (["+", "-"])? (<DIGIT>)+ >
|	< ID : <LETTER> (<LETTER> | <DIGIT>)* >
|	< INTCONST : (<SIGN>)? (<DIGIT>)+ >
|	< DOUBLECONST : (<DIGIT>)+ "." (<DIGIT>)* (<EXPONENT>)?
		| "." (<DIGIT>)+ (<EXPONENT>)?
		| (<DIGIT>)+ <EXPONENT> >
|	< STRCONST : "\"" ( (~["\"", "\n", "\r", "\\"]) | "\\" (["n", "t", "b", "r", "f", "\\", "'", "\""]) )* "\"" >

}

java.util.List start() :
{
    AbstractGlobalScopeUnit abstractGlobalScopeUnit = null;
    java.util.List abstractGlobalScopeUnits = new java.util.ArrayList();
}
{
  (
     abstractGlobalScopeUnit =  globalScopeUnit()
     { abstractGlobalScopeUnits.add(abstractGlobalScopeUnit); }

  )+
   <EOF>
   { return abstractGlobalScopeUnits; }
}

AbstractGlobalScopeUnit globalScopeUnit() :
{ AbstractGlobalScopeUnit globalScopeUnit; }
{
        LOOKAHEAD(3)
        globalScopeUnit = globalVariableDeclaration() { return globalScopeUnit; }  |
        globalScopeUnit = functionDeclaration() { return globalScopeUnit; } |
        globalScopeUnit = structDeclaration()  { return globalScopeUnit; }

}

AbstractGlobalScopeUnit functionDeclaration() :
{ Token t; java.util.List parameterList; Statement body; String returnType; }
{
	returnType = returnType() t = <ID> <LPAREN> parameterList = parameterList() <RPAREN> body = compoundStatement()

    { return new FunctionDeclaration(returnType, t.image, parameterList, body );  }
}

String returnType() :
{ Token t; String returnType; }
{
	t = <VOID> { return t.image; } | returnType = type()

	{ return returnType; }
}

String type() :
{ Token t; }
{
	    t = <INT> { return t.image; }
	|   t = <DOUBLE> { return t.image; }
	|   t = <BOOL> { return t.image; }
	|   t = <STRING> { return t.image; }
	|   t = <ID> { return t.image; }
}

java.util.List parameterList() :
{ java.util.List<Variable> parameterList; }
{
	<VOID> { return null; } | parameterList = formalList() { return parameterList; }

}

java.util.List formalList() :
{ Token t; String type; java.util.List<Variable> parameterList = new java.util.ArrayList(); }
{
	(<COMMA> (<CONST>)? type = type() t = <ID> { parameterList.add(new Variable(type, t.image)); })*

		{ return parameterList; }
}

StructDeclaration structDeclaration() :
{}
{
	<STRUCT> <ID> <LBRACE> structMemberDeclarations() <RBRACE> <SEMI>

	{ return new StructDeclaration(); }

}

StructMemberDeclaration structMemberDeclarations() :
{}
{
	type() <ID> <SEMI> (type() <ID> <SEMI>)*

		{ return new StructMemberDeclaration(); }

}

AbstractGlobalScopeUnit globalVariableDeclaration() :
{ String type; Token id, constToken = null; Expression value; }
{
	(constToken = <CONST>)? type = type() id = <ID> <ASSIGN> value = initializer() <SEMI>

	{ return new GlobalVariableDeclaration(type, id.image, value, constToken); }
}

Expression initializer() :
{ Expression expression; }
{
	expression = simpleInitializer() { return new SimpleInitializer(expression); }
	| <LBRACE> structInitializer() <RBRACE> { return new SimpleInitializer(); }
}

Expression simpleInitializer() :
{ Token t;}
{
	t = <INTCONST> { return new IntConst(Integer.parseInt(t.image)); }     |
	t = <DOUBLECONST> { return new DoubleConst(Double.parseDouble(t.image)); } |
	    <TRUE> { return new BoolExpression(true); } |
	    <FALSE> { return new BoolExpression(false); }|
    t = <STRCONST> { return new StrConst(t.image); }
}

StructInitializer structInitializer() :
{}
{
	initializer() { return new StructInitializer(); } (<COMMA> initializer() { return new StructInitializer(); })*
}

Statement compoundStatement() :
{Statement s1,s2;}
{
	<LBRACE>
	    s1 = statementList()
	    ( s2=compoundStatement() { s1 = new CompoundStatement(s1, s2); } )?
    <RBRACE>

    { return s1; }
}

Statement statementList() :
{Statement statement, statementList; }
{
	(
	    LOOKAHEAD(2)
        statement = statement()
        (
            LOOKAHEAD(2)
            statementList = statementList()
            { return new StatementList(statement, statementList); }
        )*
    )+

	{ return statement; }
}

Statement statement() :
{Statement stm;}
{
	  LOOKAHEAD(2)
      stm = variableDeclarationStatement() { return stm; }
	| stm = expressionOrAssignmentStatement() { return stm; }
	| stm = selectionStatement() { return stm; }
	| stm = compoundStatement() { return stm; }
	| stm = iterationStatement() { return stm; }
	| stm = returnStatement() { return stm; }
	| stm = breakStatement() { return stm; }
	| stm = continueStatement() { return stm; }
	| stm = printStatement() { return stm; }
}

Statement expressionOrAssignmentStatement() :
{ Expression left = null; Expression right = null; }
{
	( left = expression() (<ASSIGN> right = expression())?)? <SEMI>

	{ return new ExpressionOrAssignmentStatement(left, right); }
}

/*
void assignmentStatement() :
{}
{
	<ID> <ASSIGN> expression() <SEMI>
}

*/


/*
void expressionStatement() :
{}
{
	expression() <SEMI> | <SEMI>
}
*/



Statement variableDeclarationStatement() :
{ String type = null; Token t; Expression valueExp = null;}
{
	(<CONST>)? type = type() t = <ID> (<ASSIGN> valueExp = expression())? <SEMI>

	{ return new VariableDeclarationStatement(type, t.image, valueExp); }
}


Statement selectionStatement() :
{ Statement statement; }
{
	statement = ifStatement() { return statement; } | statement = switchStatement() { return statement; }


}

Statement ifStatement() :
{ Expression boolExpression; Statement trueBlock; Statement elseBlock = null; }
{
	<IF> <LPAREN> boolExpression = expression() <RPAREN> trueBlock = statement() (LOOKAHEAD(1) <ELSE> elseBlock = statement())?

	{ return new IfStatement(boolExpression, trueBlock, elseBlock); }
}


Statement switchStatement() :
{}
{
	<SWITCH> <LPAREN> expression() <RPAREN> <LBRACE> switchBlock() <RBRACE>

	{ return new SwitchStatement(); }
}

Statement switchBlock() :
{ Statement labelBlock, switchBlock; }
{
	labelBlock = labelBlock() ( switchBlock = labelBlock() { return new SwitchBlock(labelBlock, switchBlock); })*

	{ return labelBlock;}
}

Statement labelBlock() :
{ Expression constantExpression = null; Statement labelStatement; }
{
	<CASE> constantExpression = constantExpression() <COLON> labelStatement = labelStatement()

	| <DEFAULT_> <COLON> labelStatement = labelStatement()

	{ return new LabelBlock(constantExpression, labelStatement); }
}

Statement labelStatement() :
{ Statement statementList = null; }
{
	(statementList = statementList())?

	{ return new LabelStatement(statementList); }
}

//void constExpression() :
//{}
//{
//	<INTCONST> | <DOUBLECONST> | <TRUE> | <FALSE> | <STRCONST>
//}

Statement iterationStatement() :
{
    Token t; Expression boolExpression = null; Statement iterationBody;
    Expression forIndex = null, forIncrement = null;
}
{
	  t = <WHILE> <LPAREN> boolExpression = expression() <RPAREN> iterationBody = statement()
	      { return new WhileStatement(boolExpression, iterationBody); }

	| t = <DO> iterationBody = statement() <WHILE> <LPAREN> boolExpression = expression() <RPAREN> <SEMI>
          { return new interpreter.ast.statement.iteration.DoWhileStatement(boolExpression, iterationBody); }

	| t = <FOR> <LPAREN> (forIndex = expression())?
	        <SEMI> (boolExpression = expression())?
	        <SEMI> (forIncrement = expression())? <RPAREN>
	        iterationBody = statement()
	        { return new ForStatement(boolExpression, iterationBody, forIndex, forIncrement ); }
}
Statement returnStatement() :
{ Expression expression = null; }

{
	<RETURN> ( expression = expression())? <SEMI>

	{ return new ReturnStatement(expression); }
}

Statement breakStatement() :
{}
{
	<BREAK> <SEMI>
	{ return new BreakStatement(); }
}

Statement continueStatement() :
{}
{
	<CONTINUE> <SEMI>
	{ return new ContinueStatement(); }

}

Statement printStatement() :
{Expression e; Token t;}
{
    <PRINT> <LPAREN> e=expression() <RPAREN> <SEMI> { return new Print(e); }

}

Expression expression() :
{ Expression e; }
{
	e = logicalOr() { return e; }
}

Expression logicalOr() :
{ Expression e1, e2; }
{
	e1 = logicalAnd()
	(
		LOOKAHEAD(2)
	    <OR>  e2 = expression() { return new LogicalOR(e1, e2); }
	)?
	{ return e1; }
}

Expression logicalAnd() :
{ Expression e1, e2; }
{
	e1 = equalityExpression()
	(
		LOOKAHEAD(2)
	    <AND> e2 = expression() { return new LogicalAND(e1, e2); }
	)?

	{ return e1; }
}

Expression equalityExpression() :
{ Expression e1, e2; Token t; }
{
	e1 = relationalExpression()
	(
	    	    LOOKAHEAD(2)

	    (t = <EQUAL> | t = <NOTEQUAL>)
	    e2 = expression() { return new EqualityExpression(e1, e2, t.image); }
	)?

	{ return e1; }
}

Expression relationalExpression() :
{ Expression e1,e2; Token t; }
{
	e1 = additiveExpression()
	(
	    LOOKAHEAD(2)
	    (t = <LESSTHAN> |t = <LESSEQUAL> |t = <GREATERTHAN> |t = <GREATEREQUAL>)
	    e2 = expression() { return new RelationalExpression(e1, e2, t.image); }
	)?
	{ return e1; }
}

Expression additiveExpression() :
{ Expression e1,e2; Token t; }
{
	e1 = multiplicativeExpression()
	(
		LOOKAHEAD(2)
	    ( t = <PLUS> | t =  <MINUS>)
	    e2 = expression()  { return new AdditiveExpression(e1, e2, t.image); }
	)?
	{ return e1; }
}

Expression multiplicativeExpression() :
{ Expression e1,e2; Token t; }
{
	e1 = exponentialExpression()
	(
	    ( t = <TIMES> | t =  <DIVIDE>)
	    e2 = exponentialExpression()  { return new MultiplicativeExpression(e1, e2, t.image); }
	)*
	{ return e1; }
}

Expression exponentialExpression() :
{ Expression e1,e2;}
{
	e1 = unaryExpression()
	(
	    <POWER> e2 = unaryExpression() { return new ExponentialExpression(e1, e2); }
	)*
	{ return e1; }
}

Expression unaryExpression() :
{ Expression e1; String unaryOp = null; }
{
	   unaryOp = unaryOperator() e1 = postfixExpression() { return new UnaryExpression(e1, unaryOp); }
	 | e1 = postfixExpression() { return new UnaryExpression(e1, unaryOp); }
}

Expression postfixExpression() :
{ Expression e1; Expression e2 = null; Token t = null;}
{
	e1 = primaryExpression()
	(
	      <LBRACK> e2 = expression() <RBRACK> { return new PostfixExpression(e1, e2, t.image); }
	    | <DOT> t = <ID> { return new PostfixExpression(e1, e2, t.image); }
	)*
	{ return e1; }
}

Expression primaryExpression() :
{Expression e1,e2; Token t = null;}
{
	   e1 = constantExpression() { return new ConstantExpression(e1); }
	 | <LPAREN> e1 = expression() <RPAREN> { return new PrimaryExpression(e1, t.image); }
	 | t = <ID>  { return new IdExpression(t.image); }

}

Expression primaryExpressionPrime() :
{ Expression e1 = null; }
{
	(<LPAREN> e1 =  expressionList() <RPAREN> { return new PrimaryExpressionPrime(e1); })?
	{ return  e1; }
}

Expression expressionList() :
{ Expression e1 = null; Expression e2 = null; }
{
	( e1 = expression() (<COMMA> e2 = expression() { return new ExpressionList(e1, e2); } )* )?

	{ return new ExpressionList(e1, e2); }
}

Expression constantExpression() :
{Token t;}
{
	  t = <INTCONST> { return new IntConst(Integer.parseInt(t.image)); }
	| t = <DOUBLECONST> { return new DoubleConst(Double.parseDouble(t.image)); }
	| t = <TRUE> { return new BoolExpression(true); }
	| t = <FALSE> { return new BoolExpression(false); }
	| t = <STRCONST> { return new StrConst(t.image); }
}

String unaryOperator() :
{Token t;}
{
	t = <PLUS> | t=  <MINUS> | t =  <NOT>

	{ return t.image; }
}
